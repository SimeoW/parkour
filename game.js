const zeroVector = new THREE.Vector3(0, 0, 0);

class Game {
	constructor() {
		// An integer used to seed each server, generated by hashing the server name
		this.serverSeed = null;
		// The FPS for the game
		this.fixedTimeStep = 1 / 60;
		// The game's camera
		this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
		// The perspective of the camera
		this.fov = 20;
		// The physics scene used to simulate the objects
		this.world = new CANNON.World();
		this.world.quatNormalizeSkip = 0;
		this.world.quatNormalizeFast = false;
		this.solver = new CANNON.GSSolver();
		this.world.defaultContactMaterial.contactEquationStiffness = 1e9;
		this.world.defaultContactMaterial.contactEquationRelaxation = 4;
		this.solver.iterations = 1;
		this.solver.tolerance = 0.1;
		var split = true;
		if(split) this.world.solver = new CANNON.SplitSolver(this.solver);
		else this.world.solver = solver;

		this.scene = new THREE.Scene();
		//this.scene.fog = new THREE.Fog(0x000000, 0, 500);

		// The server's name, hashed to generate the server seed
		this.server_name = null;
		// The player's name
		this.player_name = null;
		// The websocket used to communicate with the server
		this.socket = null;
		// An array used to keep track of the game objects in the world
		this.objects = [];
		// The three.js renderer
		this.renderer = new THREE.WebGLRenderer({
			antialias: false
		});
		this.renderer.setSize(window.innerWidth, window.innerHeight);
		this.renderer.setClearColor(new THREE.Color(0x101010), 1); // scene.fog.color
		this.renderer.domElement.id = 'draw';

		//this.renderer.shadowMap.enabled = true;
		//this.renderer.shadowMap.type = THREE.PCFShadowMap; //BasicShadowMap;

		this.stats = new Stats();
		this.stats.showPanel(0);
		document.body.appendChild(this.stats.dom);

		document.getElementById('viewport').appendChild(this.renderer.domElement);

		this.spawn = null;
		this.players = [];
		this.player = null;
		this.playerScale = {
			l: 0.56,
			w: 0.1,
			h: 1
		}
		// The padding underneath the lowest object where the player respawns
		this.respawnHeightPadding = 10;
		// The chunk management system
		this.chunkManager = null;
		// Used for keyboard and mouse user input
		this.input = new Input(window);
		// Used to orbit the camera around the player
		this.controls = new THREE.CameraOrbit(this.renderer, this.scene, this.camera);
		this.controls.smoothing = 3;
		// The skybox in the world
		this.sky = this.addSkybox('', 'nebula', 'png', 5000);
		// Used to pause the physics engine
		this.paused = false;
		// Timing variables, used to ensure that tasks are done in a specific frequency
		this.currentFrameTime = (new Date()).getTime();
		this.prevFrameTime = this.currentFrameTime;
		this.lastServerUpdateTime = this.prevFrameTime;
		this.lastPositionCheckTime = this.prevFrameTime;
		// Start the game
		this.step();
	}

	// Connect to the server, returns boolean success
	connect(player_name, server_name) {
		if (this.player_name != null) return false;
		if (this.server_name != null) return false;
		if (this.socket != null) return false;
		this.player_name = player_name;
		this.server_name = server_name;

		this.serverSeed = this.hashString(server_name);
		this.chunkManager = new ChunkManager(this);

		this.socket = io();
		this.socket.emit('initialize', player_name, server_name);
		//this.socket.emit('list');
		this.addChatMessage('', 'Type "\\help" for help')

		this.socket.on('map', function(name, players, map) {
			this.player_name = name;
			this.loadMap(map);
			for (var playerState of players) {
				this.updatePlayerState(playerState);
			}
		}.bind(this)); // Make that this, this this

		this.socket.on('update_player_state', function(state) {
			this.updatePlayerState(state);
		}.bind(this));

		this.socket.on('remove_player', function(name) {
			if (typeof name != 'string') return;
			if (this.players[name] !== undefined) {
				console.log(`Removing "${name}"`);
				this.remove(this.players[name]);
				delete this.players[name];
			}
		});

		this.socket.on('chat', function(name, msg) {
			var color = '#FFFFFF';
			if (name != '') color = this.strColor(name);
			this.addChatMessage(name, msg, color);
		}.bind(this));

		this.socket.on('list', function(names) {
			names.sort();
			var html = 'Users online (server="' + this.server_name + '"):';
			for (var name of names) {
				var color = this.strColor(name);
				html += '<br><span style="color: ' + color + '">' + '•</span> <span style="color: #FFF76B">' + name + '</span>';
			}
			this.addChatMessage('', html, '#FFFFFF');
		}.bind(this));

		this.socket.on('rooms', function(rooms) {
			var html = 'Active servers:';
			for (var i in rooms) {
				var room = rooms[i][0],
					unit = rooms[i][1].toString();
				unit += (unit == '1' ? ' player' : ' players');
				html += '<br>• "<span style="color: #FFF76B">' + room + '</span>": <span style="color: #8DDBFF">' + unit + '</span>';
			}
			this.addChatMessage('', html, '#FFFFFF');
		}.bind(this));
		return true;
	}

	chat(msg) {
		if (msg.startsWith('/') || msg.startsWith('\\')) {
			var cmd = msg.substring(1);
			var words = cmd.split(/\s+/);
			if (words.length == 0) return;
			words[0] = words[0].toLowerCase();
			switch (words[0]) {
				case 'help':
					var html = '<h3>Welcome to VWORLD, you are in server "' + this.server_name + '"</h3>';
					html += '<hr>The controls are as follows:';
					html += '<br>• SPACE <span style="color: #FFF76B">: Jump</span>';
					html += '<br>• W, UP <span style="color: #FFF76B">: Move forward</span>';
					html += '<br>• A, LEFT <span style="color: #FFF76B">: Rotate camera left</span>';
					html += '<br>• S, DOWN <span style="color: #FFF76B">: Move backward</span>';
					html += '<br>• D, RIGHT <span style="color: #FFF76B">: Rotate camera right</span>';
					html += '<br>• SHIFT <span style="color: #FFF76B">: Sprint</span>';
					html += '<br>• T, ENTER <span style="color: #FFF76B">: Chat</span>';

					html += '<hr>The chat commands are as follows (~ can be anything):';
					html += '<br>• \\help <span style="color: #FFF76B">: List the available commands</span>';
					html += '<br>• \\fov ~<span style="color: #FFF76B">: Set the camera\'s field of view</span>';
					html += '<br>• \\list <span style="color: #FFF76B">: List the players currently on the server</span>';
					html += '<br>• \\pause <span style="color: #FFF76B">: Toggle the paused game state</span>';
					html += '<br>• \\rename<span style="color: #FFF76B">: Rename your character</span>';
					html += '<br>• \\reset <span style="color: #FFF76B">: Respawn</span>';
					html += '<br>• \\scale ~ ~ ~<span style="color: #FFF76B">: Set your (length, width, height)</span>';
					html += '<br>• \\server SERVER_NAME<span style="color: #FFF76B">: Move to a new server</span>';
					html += '<br>• \\servers<span style="color: #FFF76B">: List the currently active servers</span>';
					html += '<br>• \\tp PLAYER_NAME<span style="color: #FFF76B">: Teleport to a player</span>';
					html += '<br>';
					html += '<br>';
					this.addChatMessage('', html, '#FFFFFF');
					break;

				case 'list':
					this.socket.emit('list');
					break;

				case 'reset':
					this.remove(this.player);
					this.player = null;
					break;

				case 'pause':
					if (this.paused) {
						this.paused = false;
						this.addChatMessage('', 'The game has been resumed', '#FFFFFF');
					} else {
						this.paused = true;
						this.addChatMessage('', 'The game has been paused', '#FFFFFF');
					}
					break;

				case 'rename':
					localStorage.removeItem('playerName');
					location.reload();
					break;

				case 'scale':
					if (words.length != 4) {
						this.addChatMessage('', 'Invalid number of parameters. Must contain length, width, and height', '#FF4949');
						return;
					}

					var l = words[1],
						w = words[2],
						h = words[3];
					if (l == '~') l = 6;
					if (w == '~') w = 1;
					if (h == '~') h = 10;
					l = parseFloat(l);
					w = parseFloat(w);
					h = parseFloat(h);
					if (isNaN(l) || isNaN(w) || isNaN(h)) {
						this.addChatMessage('', 'Invalid parameters, must be numbers', '#FF4949');
						return;
					}
					this.playerScale = {
						l: l,
						w: w,
						h: h
					};
					this.remove(this.player);
					this.player = null;
					break;

				case 'servers':
					this.socket.emit('rooms');
					break;

				case 'server':
					if (words.length != 2) {
						this.addChatMessage('', 'Invalid number of parameters. Must contain a server name', '#FF4949');
						return;
					}

					var s = words[1];
					localStorage.setItem('serverName', s);
					location.reload();
					break;

				case 'fov':
					if (words.length != 2) {
						this.addChatMessage('', 'Invalid number of parameters. Must contain an FOV value', '#FF4949');
						return;
					}
					var fov = words[1];
					if (fov == '~') fov = 40;
					this.fov = parseFloat(fov);
					break;

				case 'tp':
					if (words.length != 2) {
						this.addChatMessage('', 'Invalid number of parameters. Must contain a player\'s name', '#FF4949');
						return;
					}
					var name = words[1],
						player;
					if (name == this.player_name) player = this.player;
					else player = this.players[name];
					if (player === undefined || this.player == null) {
						this.addChatMessage('', 'Player could not be found', '#FF4949');
						return;
					}
					this.player.position.set(player.position.x + Math.random() * 2 - 1, player.position.y + Math.random() * 2 - 1, player.position.z + Math.random() * 2 - 1);
					break;
				default:
					this.addChatMessage('', 'Command not found, type \\help for more information', '#FF4949');
			}
			document.getElementById('chat').blur();
		} else {
			msg = msg.substring(0, 256);
			this.socket.emit('chat', msg);
		}
	}

	// Clear all objects from the world
	clearMap() {
		for (var i in this.scene._objects) {
			this.remove(this.scene._objects[i]);
		}
		this.player = null;
	}

	initializePlayer() {
		// Remove the old player if not done already
		if (this.player != null) this.remove(this.player);
		// Ensure that there is a spawn
		if (this.spawn === undefined) this.spawn = zeroVector;
		var color = 0xFFFFFF;
		this.player = this.addPlayer(this.player_name, new THREE.Vector3(this.spawn.x, this.spawn.y + this.playerScale.h / 2, this.spawn.z), {
			l: this.playerScale.l,
			w: this.playerScale.w,
			h: this.playerScale.h
		}, zeroVector, color);
		this.player.previousPosition = new THREE.Vector3(this.player.position.x, this.player.position.y, this.player.position.z);
		this.player.acceleration = 0.4;
		this.player.maxVelocity = 30;
		this.player.jumping = false;
		this.player.jumpVelocity = 8;
		this.player.flying = true;
		//this.player.addEventListener('collision', function(other_object, relative_velocity, relative_rotation, contact_normal){
		//	game.player.jumping = false;
		//});
		this.controls.position = new THREE.Vector3(0, 6, -8);
		this.playerRespawnTimeout = null;
	}

	// Apply motion to the scene
	step() {
		requestAnimationFrame(this.step.bind(this));
		this.stats.begin();
		this.prevFrameTime = this.currentFrameTime;
		this.currentFrameTime = (new Date()).getTime();
		this.deltaTime = (this.currentFrameTime - this.prevFrameTime) / 1000;
		this.updateControls();
		this.input.endFrame();
		if (!this.paused) {
			if(this.chunkManager != null) this.chunkManager.step();
			this.world.step(this.fixedTimeStep);
			// Update player position
			if(this.player != null) {
				this.player.mesh.position.copy(this.player.position);
				this.player.mesh.quaternion.copy(this.player.quaternion);
			}
			// Update player positions
			for(var name in this.players) {
				if(this.players[name] === undefined) {
					delete this.players[name];
					continue;
				}
				if(this.players[name].mesh === undefined) continue;
				this.players[name].mesh.position.copy(this.players[name].position);
				this.players[name].mesh.quaternion.copy(this.players[name].quaternion);
			}
			// Update object positions
			for(var i in this.objects) {
				if(this.objects[i] === undefined) {
					delete this.objects[i];
					continue;
				}
				if(this.objects[i].mesh === undefined) continue;
				this.objects[i].mesh.position.copy(this.objects[i].position);
				this.objects[i].mesh.quaternion.copy(this.objects[i].quaternion);
			}

			this.playerMovement();
			this.updateCamera();
			this.renderer.render(this.scene, this.camera);
		} else {
			this.updateCamera();
			this.renderer.render(this.scene, this.camera);
		}
		this.stats.end();
	}

	// Update the camera by applying a smooth transition to the next player's position
	updateCamera() {
		if (this.player == null) return;
		var x = (this.controls.target.x * this.controls.smoothing + this.player.position.x) / (this.controls.smoothing + 1);
		var y = (this.controls.target.y * this.controls.smoothing + this.player.position.y) / (this.controls.smoothing + 1);
		var z = (this.controls.target.z * this.controls.smoothing + this.player.position.z) / (this.controls.smoothing + 1);
		this.controls.target = new THREE.Vector3(x, y, z);
		this.camera.setFocalLength(this.fov);
	}

	// Handle the camera orbit
	updateControls() {
		var rotateCamera = this.input.isLeftDown;
		var moveCamera = false;
		var mouseDeltaX = this.input.mouseDeltaX;
		var mouseDeltaY = this.input.mouseDeltaY;
		var zoom = this.input.scrollY;
		mouseDeltaX /= 3;
		mouseDeltaY /= 3;
		if (document.activeElement.id != 'chat') {
			if (this.input.isKeyDown['-'] || this.input.isKeyDown['pagedown']) zoom += 10;
			else if (this.input.isKeyDown['+'] || this.input.isKeyDown['pageup']) zoom -= 10;

			if (this.input.isKeyDown['arrowleft'] || this.input.isKeyDown['a']) {
				rotateCamera = true;
				mouseDeltaX -= 3;
			}
			if (this.input.isKeyDown['arrowright'] || this.input.isKeyDown['d']) {
				rotateCamera = true;
				mouseDeltaX += 3;
			}
		}

		var controllerInput = {
			deltaTime: this.deltaTime, // time passed, in seconds, since last update call
			rotateHorizontally: rotateCamera ? -mouseDeltaX : 0, // rotation around y axis
			rotateVertically: rotateCamera ? -mouseDeltaY : 0, // rotate vertically around x / z axis
			moveOffsetVertically: 0, // (moveCamera ? -mouseDeltaY : 0) * 10, // move the target offset (affect lookat AND camera position), along camera's Y axis.
			moveOffsetHorizontally: 0, // (moveCamera ? mouseDeltaX : 0) * 10, // move the target offset left / right, relative to camera's world direction.
			zoom: zoom * 10, // zoom in or out
		}
		this.controls.update(controllerInput);
	}

	// Handle the player's movement
	playerMovement() {
		if (this.player == null || this.player === undefined || isNaN(this.player.position.x)) {
			if (this.playerRespawnTimeout == null) {
				this.playerRespawnTimeout = setTimeout(function() {
					this.initializePlayer();
				}.bind(this), 1000);
			}
			return;
		}

		var x = Math.floor(this.player.position.x / this.chunkSize);
		var y = Math.floor(this.player.position.y / this.chunkSize);
		var z = Math.floor(this.player.position.z / this.chunkSize);
		if (document.activeElement.id != 'chat') {
			// TODO
			//if (this.player != null && this.player._physijs.touches.length > 0) this.player.jumping = false;
			if (this.player != null && this.player.flying) this.player.jumping = false;

			if (!this.player.jumping) {
				// Sprinting
				var maxVelocity = this.player.maxVelocity;
				if (this.input.isKeyDown['shift']) maxVelocity *= 1.25;
				// Moving forward
				var forward = (this.input.isKeyDown['arrowup'] || this.input.isKeyDown['w']);
				if(this.input.isTouching && this.input.mouseY < this.height / 4) forward = true;
				if (forward) {
					this.updatePlayerRotation();

					// 2D angle
					var vx2 = game.player.position.x - game.camera.position.x;
					var vz2 = game.player.position.z - game.camera.position.z;
					var dt = Math.sqrt(vx2 * vx2 + vz2 * vz2);

					if (dt != 0) {
						var v = this.player.velocity;
						var vx = v.x + this.player.acceleration * vx2 / dt;
						var vz = v.z + this.player.acceleration * vz2 / dt;
						/*var v = this.player.velocity;
						var vx = v.x + this.player.acceleration * vx2 / dt;
						var vz = v.z + this.player.acceleration * vz2 / dt;*/

						var vel = Math.sqrt(vx * vx + vz * vz);
						if (vel > maxVelocity) { // Limit velocity
							vx = vx / vel * maxVelocity
							vz = vz / vel * maxVelocity
						}
						this.player.velocity.set(vx, v.y, vz);
						this.player.angularVelocity.set(0, 0, 0);
					} else {
						console.log('Error: distance is 0')
					}
				}
				// Moving backward
				var backward = (this.input.isKeyDown['arrowdown'] || this.input.isKeyDown['s']);
				if(this.input.isTouching && this.input.mouseY > this.height - this.height / 4) backward = true;
				if (backward) {
					this.updatePlayerRotation();

					// 2D angle
					var vx2 = game.player.position.x - game.camera.position.x;
					var vz2 = game.player.position.z - game.camera.position.z;
					var dt = Math.sqrt(vx2 * vx2 + vz2 * vz2);

					if (dt != 0) {
						var v = this.player.velocity;
						var vx = v.x - this.player.acceleration * vx2 / dt;
						var vz = v.z - this.player.acceleration * vz2 / dt;

						var vel = Math.sqrt(vx * vx + vz * vz);
						if (vel > maxVelocity) { // Limit velocity
							vx = vx / vel * maxVelocity
							vz = vz / vel * maxVelocity
						}
						this.player.velocity.set(vx, v.y, vz);
						this.player.angularVelocity.set(0, 0, 0);
					} else {
						console.log('Error: distance is 0')
					}
				}
				// Jumping
				if (this.input.isKeyDown[' ']) {
					var v = this.player.velocity;
					if (v.y < 0) v.y = 0;
					//this.player.applyCentralImpulse(new THREE.Vector3(0, this.player.jumpVelocity, 0))
					this.player.velocity.set(v.x, this.player.jumpVelocity, v.z);
					this.player.jumping = true;
				}
			} else { // While the player is in the air, grant a small amount of influence
				var influenceVelocity = 0.01;
				// Moving forward
				if (this.input.isKeyDown['arrowup'] || this.input.isKeyDown['w']) {
					var vx2 = game.player.position.x - game.camera.position.x;
					var vz2 = game.player.position.z - game.camera.position.z;
					var dt = Math.sqrt(vx2 * vx2 + vz2 * vz2);
					if (dt != 0) {
						var v = this.player.velocity;
						var vx = v.x + influenceVelocity * vx2 / dt;
						var vz = v.z + influenceVelocity * vz2 / dt;

						//var vel = Math.sqrt(vx * vx + vz * vz);
						//if(vel > this.player.maxVelocity) { // Limit velocity
						//	vx = vx2 / dt * this.player.maxVelocity
						//	vz = vz2 / dt * this.player.maxVelocity
						//}
						this.player.velocity.set(vx, v.y, vz);
					} else {
						console.log('Error: distance is 0')
					}
				}
				// Moving backward
				if (this.input.isKeyDown['arrowdown'] || this.input.isKeyDown['s']) {
					var vx2 = game.player.position.x - game.camera.position.x;
					var vz2 = game.player.position.z - game.camera.position.z;
					var dt = Math.sqrt(vx2 * vx2 + vz2 * vz2);
					if (dt != 0) {
						var v = this.player.velocity;
						var vx = v.x - influenceVelocity * vx2 / dt;
						var vz = v.z - influenceVelocity * vz2 / dt;

						//var vel = Math.sqrt(vx * vx + vz * vz);
						//if(vel > this.player.maxVelocity) { // Limit velocity
						//	vx = -vx2 / dt * this.player.maxVelocity
						//	vz = -vz2 / dt * this.player.maxVelocity
						//}
						this.player.velocity.set(vx, v.y, vz);
					} else {
						console.log('Error: distance is 0')
					}
				}
			}
		}


		this.sky.position.set(this.player.position.x, this.player.position.y, this.player.position.z)

		// Every second, check if the player has not moved, if no, then grant access to a free jump
		if (this.currentFrameTime - this.lastPositionCheckTime >= 1000) {
			// If the player has not moved
			if (this.player.position.x == this.player.previousPosition.x && this.player.position.y == this.player.previousPosition.y && this.player.position.z == this.player.previousPosition.z) {
				this.player.jumping = false;
			}
			this.player.previousPosition = new THREE.Vector3(this.player.position.x, this.player.position.y, this.player.position.z);
			this.lastPositionCheckTime = (new Date()).getTime();
		}
		// Update the server
		if (this.currentFrameTime - this.lastServerUpdateTime >= 50) {
			var p = this.player.position,
				q = this.player.quaternion,
				v = this.player.velocity,
				av = this.player.angularVelocity;
			this.socket.emit('update_player_state', [p.x, p.y, p.z, q.x, q.y, q.z, q.w, v.x, v.y, v.z, av.x, av.y, av.z, this.player.length, this.player.width, this.player.height]);
			this.lastServerUpdateTime = (new Date()).getTime();
		}

		// Falling out of bounds, pick the lowest respawn height (manually added objects vs. chunk)
		var respawnHeight = this.respawnHeight;
		if(this.chunkManager.playerChunkRespawnHeight != null) {
			respawnHeight = Math.min(respawnHeight, this.chunkManager.playerChunkRespawnHeight);
		}
		if (this.player.position.y < respawnHeight) {
			this.remove(this.player);
			this.player = null;
		}
	}

	// Update a player's position, rotation, scale, and velocities
	updatePlayerState(state) {
		var name = state.shift();
		if (typeof name != 'string' || state.length != 16) return;
		if (this.player != null && name == this.player_name) return; // Ignore self

		for (var item of state) { // If anything is not a number, ignore the message
			if (typeof item != 'number') return;
		}

		var p = this.players[name];
		var color = 0xFFFFFF;
		//[p.x, p.y, p.z, q.x, q.y, q.z, q.w, v.x, v.y, v.z, av.x, av.y, av.z, this.player.length, this.player.width, this.player.height]);
		if (p === undefined) { // Create online player object
			p = this.addPlayer(name, new THREE.Vector3(state[0], state[1], state[2]), {
				l: state[13],
				w: state[14],
				h: state[15] // TODO: quaternion x,y,z,w: state[3], state[4], state[5], state[6]
			}, new THREE.Vector3(0, 0, 0), color);
			p.velocity.set(state[7], state[8], state[9]);
			p.angularVelocity.set(state[10], state[11], state[12]);
			this.players[name] = p;
		} else { // Update player position
			var l = state[13], w = state[14], h = state[15];
			if (p.length != l || p.width != w || p.height != h) {
				// One of the scales changed, we need to reset the player
				p = this.players[name] = p.setScale(l, w, h);
			}

			p.position.set(state[0], state[1], state[2]);
			p.quaternion.set(state[3], state[4], state[5], state[6]);
			try {
				p.velocity.set(state[7], state[8], state[9]);
				p.angularVelocity.set(state[10], state[11], state[12]);
			} catch (e) {}
		}
	}

	// Set the player's rotation to the camera direction
	updatePlayerRotation() {
		var vx = game.player.position.x - game.camera.position.x;
		var vz = game.player.position.z - game.camera.position.z;
		var dt = Math.sqrt(vx * vx + vz * vz);
		var theta = Math.atan2(vx, vz);
		if (theta < 0) theta += 2 * Math.PI;
		// Keep player upright, facing against the camera
		this.player.quaternion.setFromEuler(0, theta, 0);

	}

	// Get/set paused
	get paused() {
		return this._paused;
	}
	set paused(bool) {
		//if (!bool) this.scene.onSimulationResume();
		this._paused = bool;
	}

	// Get/set spawn
	get spawn() {
		return this._spawn;
	}
	set spawn(position) {
		this._spawn = position;
	}

	// Get the hash of a string, used for the server seed
	hashString(str) {
		str = str.trim() + ' ';
		var hash = 0;
		for (var i = 0; i < str.length; i++) {
			hash = str.charCodeAt(i) + ((hash << 5) - hash);
		}
		return hash;
	}

	// Given a string, compute a corresponding color
	strColor(str) {
		var hash = this.hashString(str);
		var c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
		return '#' + ('00000'.substring(0, 6 - c.length) + c);
	}

	// Given a color, returns a black or white color for the background/foreground
	strBWColor(hex) {
		if (hex.indexOf('#') === 0) hex = hex.slice(1);
		if (hex.length === 3) {
			hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
		}
		if (hex.length != 6) {
			throw new Error('Invalid HEX color.');
		}
		var r = parseInt(hex.slice(0, 2), 16),
			g = parseInt(hex.slice(2, 4), 16),
			b = parseInt(hex.slice(4, 6), 16);
		return (r * 0.299 + g * 0.587 + b * 0.114) > 186 ? '#000000' : '#FFFFFF';
	}

	addChatMessage(name, msg, color) {
		var html = '';
		if (name == '') {
			html = '<tr><td id="chatserver" style="color: ' + color + '">' + msg + '</td></tr>';
		} else {
			var bw = this.strBWColor(color);
			html = '<tr><td><span id="chatname" style="color: ' + bw + '; background-color: ' + color + '">' + name + '</span><span id="chatcontents">' + msg + '</span></td></tr>';
		}
		var chatfeed = document.getElementById('chatfeed');
		chatfeed.innerHTML += html;
		if (chatfeed.children.length > 5) chatfeed.children[0].remove();
	}

	// Load map from JSON object
	loadMap(map) {
		this.clearMap();
		console.log('Loading map...');
		if (map['objects'] === undefined) return false;

		// Set the spawn location
		if (map['spawn'] !== undefined && map.spawn.length == 3) {
			this.spawn = new THREE.Vector3(map.spawn[0], map.spawn[1], map.spawn[2]);
		} else return false;

		// Set the gravity
		if (map['gravity'] !== undefined && map.gravity.length == 3) {
			this.world.gravity.set(map.gravity[0], map.gravity[1], map.gravity[2]);
		} else return false;

		this.respawnHeight = Infinity;

		// Add each object one by one
		for (var objectDefinition of map.objects) {
			var success = this.addObjectFromDefinition(objectDefinition)
			if (!success) {
				console.log('Failed to load object:');
				console.log(objectDefinition);
			}
		}
		this.respawnHeight -= this.respawnHeightPadding;
		this.initializePlayer();
		this.chunkManager.step();
	}

	// Given an object definition, put it into the world
	addObjectFromDefinition(object) {
		var type = object[0];
		if (typeof type != 'string') return false;
		var name = object[1];
		if (typeof name != 'string') return false;
		if (name.trim() == "") name = type; // Set the default to the type

		switch (type) {
			// 'cube', 'name', px, py, pz, length, width, height, rx, ry, rz, color, friction, restitution, mass
			case 'cube':
				if (object.length != 9) return false;
				var position = object[2];
				if (position.length != 3) return false;
				var positionVector = new THREE.Vector3(position[0], position[1], position[2])
				var scale = object[3];
				if (scale.length != 3) return false;
				var rotation = object[4];
				if (rotation.length != 3) return false;
				var rotationVector = new THREE.Vector3(rotation[0], rotation[1], rotation[2])
				var color = object[5];
				if (typeof color != 'string') return false;
				var friction = object[6];
				if (typeof friction != 'number') return false;
				var restitution = object[7];
				if (typeof restitution != 'number') return false;
				var mass = object[8];
				if (typeof mass != 'number') return false;
				this.addCube(name, positionVector, scale, rotationVector, color, friction, restitution, mass);

				var minHeight = positionVector.y - scale[1] / 2;
				if (minHeight < this.respawnHeight) this.respawnHeight = minHeight;
				break;

			// 'sphere', 'name', px, py, pz, radius, rx, ry, rz, color, friction, restitution, mass
			case 'sphere':
				if (object.length != 8) return false;
				var position = object[2];
				if (position.length != 3) return false;
				var positionVector = new THREE.Vector3(position[0], position[1], position[2])
				var radius = object[3];
				if (typeof radius != 'number') return false;
				var rotation = object[4];
				if (rotation.length != 3) return false;
				var rotationVector = new THREE.Vector3(rotation[0], rotation[1], rotation[2])
				var color = object[4];
				if (typeof color != 'string') return false;
				var friction = object[5];
				if (typeof friction != 'number') return false;
				var restitution = object[6];
				if (typeof restitution != 'number') return false;
				var mass = object[7];
				if (typeof mass != 'number') return false;
				this.addSphere(name, positionVector, rotationVector, radius, color, friction, restitution, mass);

				var minHeight = positionVector.y - radius;
				if (minHeight < this.respawnHeight) this.respawnHeight = minHeight;
				break;

			// 'cylinder', 'name', [px, py, pz], radiusTop, radiusBottom, height, numSegments, [rx, ry, rz], color, friction, restitution, mass
			case 'cylinder':
				if (object.length != 12) return false;
				var position = object[2];
				if (position.length != 3) return false;
				var positionVector = new THREE.Vector3(position[0], position[1], position[2])
				var radiusTop = object[3];
				if (typeof radiusTop != 'number') return false;
				var radiusBottom = object[4];
				if (typeof radiusBottom != 'number') return false;
				var height = object[5];
				if (typeof height != 'number') return false;
				var numSegments = object[6];
				if (typeof numSegments != 'number') return false;
				var rotation = object[7];
				if (rotation.length != 3) return false;
				var rotationVector = new THREE.Vector3(rotation[0], rotation[1], rotation[2])
				var color = object[8];
				if (typeof color != 'string') return false;
				var friction = object[9];
				if (typeof friction != 'number') return false;
				var restitution = object[10];
				if (typeof restitution != 'number') return false;
				var mass = object[11];
				if (typeof mass != 'number') return false;
				this.addCylinder(name, positionVector, radiusTop, radiusBottom, height, numSegments, rotationVector, color, friction, restitution, mass);

				var minHeight = positionVector.y - scale[1] / 2;
				if (minHeight < this.respawnHeight) this.respawnHeight = minHeight;
				break;

			case 'plane':
				if (object.length != 9) return false;
				var position = object[2];
				if (position.length != 3) return false;
				var positionVector = new THREE.Vector3(position[0], position[1], position[2])
				var width = object[3];
				if (typeof width != 'number') return false;
				var height = object[4];
				if (typeof height != 'number') return false;
				var rotation = object[5];
				console.log('Plane')
				if (rotation.length != 3) return false;
				var rotationVector = new THREE.Vector3(rotation[0], rotation[1], rotation[2])
				var color = object[6];
				if (typeof color != 'string') return false;
				var friction = object[7];
				if (typeof friction != 'number') return false;
				var restitution = object[8];
				if (typeof restitution != 'number') return false;
				this.addPlane(name, positionVector, width, height, rotationVector, color, friction, restitution);

				var minHeight = positionVector.y;
				if (minHeight < this.respawnHeight) this.respawnHeight = minHeight;
				break;

			case 'skybox':
				if (object.length != 5) return false;
				var texture = object[2];
				if (typeof texture != 'string') return false;
				var fileType = object[3];
				if (fileType != 'png' && fileType != 'jpg') return false;
				var size = object[4];
				if (typeof size != 'number') return false;
				this.addSkybox(name, texture, fileType, size);
				break;

			case 'pointlight':
				if (object.length != 6) return false;
				var position = object[2];
				if (position.length != 3) return false;
				var positionVector = new THREE.Vector3(position[0], position[1], position[2])
				var color = object[3];
				if (typeof color != 'string') return false;
				var distance = object[4];
				if (typeof distance != 'number') return false;
				var decay = object[5];
				if (typeof decay != 'number') return false;
				this.addPointLight(name, positionVector, color, distance, decay);
				break;

			case 'ambientlight':
				if (object.length != 4) return false;
				var color = object[2];
				if (typeof color != 'string') return false;
				var intensity = object[3];
				if (typeof intensity != 'number') return false;
				this.addAmbientLight(name, color, intensity);
				break;

			case 'directionallight':
				if (object.length != 5) return false;
				var position = object[2];
				if (position.length != 3) return false;
				var positionVector = new THREE.Vector3(position[0], position[1], position[2])
				var color = object[3];
				if (typeof color != 'string') return false;
				var intensity = object[4];
				if (typeof intensity != 'number') return false;
				this.addDirectionalLight(name, positionVector, color, intensity);
				break;

			default:
				console.log(`Unknown object "${name}"`);
				return false;
		}
		return true;
	}

	// Add an object to the world
	add(object) {
		if (object == null || object === undefined) return;

		if(object instanceof CANNON.Body) {
			this.world.addBody(object);
		}

		if(object instanceof THREE.Object3D) {
			this.scene.add(object);
		} else if(object.mesh instanceof THREE.Object3D) {
			this.scene.add(object.mesh);
		}
		
	}

	// Remove an object from the world
	remove(object) {
		let index = this.objects.indexOf(object);
		if(index > -1) this.objects.splice(index, 1);
		if (object == null || object === undefined) return false;
		if (object.label != null || object.label !== undefined) {
			this.scene.remove(object.label)
		}
		//object.position.set(0, 300, 0);
		//object.visible = false;
		this.scene.remove(object.mesh);
		this.scene.remove(object);
		this.world.removeBody(object);
		//object.geometry.dispose();
		//object.material.dispose();
		//this.renderer.renderLists.dispose();
		return true;
	}

	// Display a bounding box around a mesh, with a specified color
	showBoundingBox(mesh, color) {
		if(!mesh.boundingBox) {
			if(!mesh.geometry) return false;
			if(mesh.geometry.boundingBox == null) {
				mesh.geometry.computeBoundingBox();
			}
			var box = mesh.geometry.boundingBox;
			// box = new THREE.Box3().setFromObject(mesh);
			var helper = new THREE.Box3Helper(box, color);
			helper.material.linewidth = 20;
			mesh.add(helper);
			mesh.boundingBox = helper;
		} else {
			mesh.boundingBox.material.color.setHex(color);
			mesh.boundingBox.visible = true;
		}
		return true;
	}

	// Hide a bounding box if it exists
	hideBoundingBox(mesh) {
		if(!mesh.boundingBox) return false;
		mesh.remove(mesh.boundingBox);
		mesh.boundingBox = null;
		return true;
	}

	addCube(name, position, scale, rotation, color, friction, restitution, mass) {
		// TODO add scale and other attributes
		var material = new THREE.MeshStandardMaterial({
			color: new THREE.Color(color),
			roughness: 0.5,
			flatShading: true,
		});
		var halfExtents = new CANNON.Vec3(scale[0] / 2, scale[1] / 2, scale[2] / 2);
		var cubeShape = new CANNON.Box(halfExtents);
		var cubeGeometry = new THREE.BoxGeometry(scale[0], scale[1], scale[2]);
		var cube = new CANNON.Body({
			mass: mass
		});
		cube.meshName = name;
		cube.meshType = 'cube';
		cube.addShape(cubeShape);
		var cubeMesh = new THREE.Mesh(cubeGeometry, material);

		cube.position.set(position.x, position.y, position.z);
		cubeMesh.position.set(position.x, position.y, position.z);
		var rx = THREE.Math.degToRad(rotation.x), ry = THREE.Math.degToRad(rotation.y), rz = THREE.Math.degToRad(rotation.z);
		cube.quaternion.setFromEuler(rx, ry, rz);
		//cubeMesh.castShadow = true;
		//cubeMesh.receiveShadow = true;

		cube.mesh = cubeMesh;
		this.objects.push(cube);
		this.add(cube)
		return cube;
	}

	addSphere(name, position, radius, rotation, color, friction, restitution, mass) {
		var material = new THREE.MeshStandardMaterial({
			color: new THREE.Color(color),
			roughness: 0.5,
			flatShading: true,
		});
		var sphereShape = new CANNON.Sphere(radius);
		var sphereGeometry = new THREE.SphereGeometry(sphereShape.radius, 32, 32);
		var sphere = new CANNON.Body({
			mass: mass
		});
		sphere.meshName = name;
		sphere.meshType = 'sphere';
		sphere.addShape(sphereShape);
		var sphereMesh = new THREE.Mesh(sphereGeometry, material);

		sphere.position.set(position.x, position.y, position.z);
		sphereMesh.position.set(position.x, position.y, position.z);
		var rx = THREE.Math.degToRad(rotation.x), ry = THREE.Math.degToRad(rotation.y), rz = THREE.Math.degToRad(rotation.z);
		sphere.quaternion.setFromEuler(rx, ry, rz);
		//sphereMesh.castShadow = true;
		//sphereMesh.receiveShadow = true;

		sphere.mesh = sphereMesh;
		this.objects.push(sphere);
		this.add(sphere);
		return sphere;
	}

	addCylinder(name, position, radiusTop, radiusBottom, height, numSegments, rotation, color, friction, restitution, mass) {
		var material = new THREE.MeshStandardMaterial({
			color: new THREE.Color(color),
			roughness: 0.5,
			flatShading: true,
		});
		var cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);
		var cylinderGeometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, numSegments);
		var cylinder = new CANNON.Body({
			mass: mass
		});
		cylinder.meshName = name;
		cylinder.meshType = 'cylinder';
		cylinder.addShape(cylinderShape);
		var cylinderMesh = new THREE.Mesh(cylinderGeometry, material);

		cylinder.position.set(position.x, position.y, position.z);
		cylinderMesh.position.set(position.x, position.y, position.z);
		var rx = THREE.Math.degToRad(rotation.x), ry = THREE.Math.degToRad(rotation.y), rz = THREE.Math.degToRad(rotation.z);
		cylinder.quaternion.setFromEuler(rx, ry, rz);
		//cylinderMesh.castShadow = true;
		//cylinderMesh.receiveShadow = true;

		cylinder.mesh = cylinderMesh;
		this.objects.push(cylinder);
		this.add(cylinder);
		return cylinder;
	}

	// TODO: Apply scale, rotation, ...
	addPlayer(name, position, scale, rotation, color, friction = 0.8, restitution = 0.1, mass = 10) {
		var material = new THREE.MeshBasicMaterial({
			color: new THREE.Color(color)
		});

		var halfExtents = new CANNON.Vec3(scale.w / 2, scale.h / 2, scale.l / 2);
		var cubeShape = new CANNON.Box(halfExtents);

		var playerGeometry = new THREE.Geometry();
		playerGeometry.vertices = [
			new THREE.Vector3(-scale.w / 2, -scale.h / 2, 0),
			new THREE.Vector3(-scale.w / 2, scale.h / 2, 0),
			new THREE.Vector3(scale.w / 2, scale.h / 2, 0),
			new THREE.Vector3(scale.w / 2, -scale.h / 2, 0),
			new THREE.Vector3(0, 0, scale.l)
		];
		playerGeometry.faces = [
			new THREE.Face3(0, 1, 2),
			new THREE.Face3(0, 2, 3),
			new THREE.Face3(1, 0, 4),
			new THREE.Face3(2, 1, 4),
			new THREE.Face3(3, 2, 4),
			new THREE.Face3(0, 3, 4)
		];

		var player = new CANNON.Body({
			mass: mass
		});
		player.meshName = name;
		player.meshType = 'player';
		player.length = scale.l;
		player.width = scwale.w;
		player.height = scale.h;
		player.addShape(cubeShape);
		var playerMesh = new THREE.Mesh(playerGeometry, material);

		player.position.set(position.x, position.y, position.z);
		playerMesh.position.set(position.x, position.y, position.z);
		var rx = THREE.Math.degToRad(rotation.x), ry = THREE.Math.degToRad(rotation.y), rz = THREE.Math.degToRad(rotation.z);
		player.quaternion.setFromEuler(rx, ry, rz);
		//playerMesh.castShadow = true;
		//playerMesh.receiveShadow = true;
		var _color = this.strColor(name);
		// Glow
		playerMesh.glow = this.addPointLight(name, zeroVector, _color, 3, 100);
		playerMesh.add(playerMesh.glow);

		// Name
		playerMesh.label = new THREE.TextSprite({
			text: name,
			fontFamily: 'Helvetica, Arial, sans-serif',
			fontSize: 0.4,
			fillColor: 0xFFFFFF,
		});
		playerMesh.label.position.set(0, scale.h / 2 + 0.4, 0);
		playerMesh.label.material.depthTest = false;
		playerMesh.add(playerMesh.label);

		player.mesh = playerMesh;

		player.setScale = (l, w, h) => {
			//player.shape.halfExtents.x = w / 2;
			//player.shape.halfExtents.y = h / 2;
			//player.shape.halfExtents.z = l / 2;
			var scale = {
				l: l,
				w: w,
				h: h
			};
			this.remove(player);
			player = this.addPlayer(name, position, scale, rotation, color, friction, restitution, mass);
			return player;
		}

		this.add(player);
		return player;
	}

	addPlane(name, position, width, height, rotation, color, friction, restitution) {
		var material = new THREE.MeshStandardMaterial({
			color: new THREE.Color(color),
			roughness: 0.5,
			flatShading: true,
		});
		var planeShape = new CANNON.Plane();
		//var planeGeometry = new THREE.PlaneGeometry();
		var plane = new CANNON.Body({
			mass: 0
		});
		plane.meshName = name;
		plane.meshType = 'plane';
		plane.addShape(planeShape);
		//var planeMesh = new THREE.Mesh(planeGeometry, material);

		this.world.addBody(plane);
		//this.scene.add(planeMesh);

		/*planeBody.position.set(position.x, position.y, position.z);
		planeMesh.position.set(position.x, position.y, position.z);
		var rx = THREE.Math.degToRad(rotation.x), ry = THREE.Math.degToRad(rotation.y), rz = THREE.Math.degToRad(rotation.z);
		//planeBody.rotation.set(rx, ry, rz);
		planeMesh.rotation.set(rx, ry, rz);
		planeMesh.castShadow = true;
		planeMesh.receiveShadow = true;
		console.log('plane body');
		console.log(planeBody);
		console.log('mesh');
		console.log(planeMesh);
		this.objects.push(planeBody);*/

		/*
		var plane = new Physijs.PlaneMesh(
			new THREE.PlaneGeometry(width, height),
			Physijs.createMaterial(new THREE.MeshStandardMaterial({
				color: new THREE.Color(color),
				roughness: 0.5,
				side: THREE.DoubleSide
			}), friction, restitution)
		);
		plane.meshName = name;
		plane.meshType = 'plane';
		plane.rotation.set(THREE.Math.degToRad(rotation.x), THREE.Math.degToRad(rotation.y), THREE.Math.degToRad(rotation.z));
		plane.position.set(position.x, position.y, position.z);
		plane.receiveShadow = true;
		plane.castShadow = true;
		this.objects.push(plane);
		this.add(plane);
		return plane;*/
	}

	addSkybox(name, texture, fileType, size) {
		if(this.sky != null) this.remove(this.sky);
		var materialArray = [],
			loader = new THREE.TextureLoader();
		materialArray.push(new THREE.MeshBasicMaterial({
			map: loader.load('skyboxes/' + texture + '-xpos.' + fileType)
		}));
		materialArray.push(new THREE.MeshBasicMaterial({
			map: loader.load('skyboxes/' + texture + '-xneg.' + fileType)
		}));
		materialArray.push(new THREE.MeshBasicMaterial({
			map: loader.load('skyboxes/' + texture + '-ypos.' + fileType)
		}));
		materialArray.push(new THREE.MeshBasicMaterial({
			map: loader.load('skyboxes/' + texture + '-yneg.' + fileType)
		}));
		materialArray.push(new THREE.MeshBasicMaterial({
			map: loader.load('skyboxes/' + texture + '-zpos.' + fileType)
		}));
		materialArray.push(new THREE.MeshBasicMaterial({
			map: loader.load('skyboxes/' + texture + '-zneg.' + fileType)
		}));
		for (var i = 0; i < 6; i++) {
			materialArray[i].side = THREE.BackSide;
		}
		var skyboxGeometry = new THREE.CubeGeometry(size, size, size, 1, 1, 1);
		var skybox = new THREE.Mesh(skyboxGeometry, materialArray);
		skybox.meshName = name;
		skybox.meshType = 'skybox';

		this.sky = skybox;
		this.add(skybox);
		return skybox;
	}

	addPointLight(name, position, color, distance, decay) {
		var light = new THREE.PointLight(new THREE.Color(color), distance, decay);
		light.meshName = name;
		light.meshType = 'pointlight';
		light.position.set(position.x, position.y, position.z);
		this.objects.push(light);
		this.add(light);
		return light;
	}

	addAmbientLight(name, color, intensity) {
		var light = new THREE.AmbientLight(new THREE.Color(color), intensity);
		light.meshName = name;
		light.meshType = 'ambientlight';
		this.objects.push(light);
		this.add(light);
		return light;
	}

	addDirectionalLight(name, position, color, intensity) {
		var light = new THREE.DirectionalLight(0xFFFFFF, intensity);
		light.meshName = name;
		light.meshType = 'directionallight';

		//light.shadow.mapSize.width = 512;  // default
		//light.shadow.mapSize.height = 512; // default
		//light.shadow.camera.near = 0.5;    // default
		//light.shadow.camera.far = 500;     // default

		//light.castShadow = true;
		/*
		light.shadow.camera = new THREE.CameraHelper(light.shadow.camera)
		light.mapSize.width = light.mapSize.height = 2048;
		light.shadow.camera.left = -50;
		light.shadow.camera.right = 50;
		light.shadow.camera.top = 50;
		light.shadow.camera.bottom = -50;
		light.shadow.camera.far = 500;
		light.shadowDarkness = 0.5;*/

		light.position.set(position.x, position.y, position.z);
		this.objects.push(light);
		//this.add(new THREE.CameraHelper(light.shadow.camera));
		this.add(light);
		return light;
	}
}